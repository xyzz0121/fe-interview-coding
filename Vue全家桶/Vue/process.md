### 流程图及笔记
由表及里，由浅入深

#### 0、项目构建
- rollup 专注打包js 简洁 包小 也没有webpack require那一堆东西 做项目webpack  写js库用rollup更好 vue 和react 都是用的rollup
#### 1、Vue用法是
```
const vm = new Vue({
    el: "#app",
    data : function(){
        return { value : 1}
    }
})
```
#### 2、所以 Vue 应该是一个类
```
function Vue(){}
为啥不用class，不方便拓展，class原型一般都写在{}里，不利于拆分，所以也源码也没用class
为啥要拆分，也不能所有原型方法都写在一个文件里，不方便阅读，不利于之策划分，所以拆成不同的插件
插件是什么？函数。
函数里面是什么？为构造函数添加原型方法。
所以有一堆插件，来拼出完成的vue原型方法
```
#### 3、数据是一切的基础，所以我们先初始化数据
写一个 initMixin 插件用于初始化
这里实现
1、实例的$options 
2、状态初始化 data props watch computed 

vue 不是一个mvvm框架，因为它可以操作dom（$ref）。mvvm是啥意思？数据变化视图会更新，视图变化数据会被影响，不能跳过数据去直接去更新视图

#### 4、初始化完数据，需要把数据变成响应式（对象）

使用defineproperty，全递归，把一个普通对象变成1个响应式对象
vue2 响应式 性能差 也是因为这个

#### 5、实现对象响应式之后，实现数组响应式

为什么数组单独实现？ 因为我们开发的时候很少对数组索引进行操作，而且如果数组非常大，100万项，遍历整个数组添加get set变成一个响应式数据，啥也不用干，就卡死了，所以为了性能问题，不用defineProperty对数组进行拦截。

那怎么把数组进行响应式呢？
重写可以改变数组的方法，数组改变时，进行通知。

这里需要注意，数组中对象如何进行响应式
以及后添加的数组元素，也需要重新进行数组对象检测

#### 5、之前一直用 vm._data.xx取值和设置值，代理vm.xx到vm._data.xx,实现真正的vm.xx

还是使用Object.defineProperty

其他事情：抽离一些工具方法

#### 6、数据初始化都完成了，该把数据渲染到模板上了， 把html编译成AST

vue渲染逻辑优先级
1、优先找render函数
2、template模板
3、el内的html结构

开启渲染
1、new vue的时候有el
2、调用$mount方法

AST和虚拟dom有啥区别？
一个是对语法转义的，一个是对dom转义的，虚拟dom还可以自定义属性来描述一个dom。
AST可以描述所有语法，html\css\js，虚拟dom只能描述dom。

尤大：前端会编译原理，想干啥干啥

前端必须要掌握的数据结构：树 （遍历、生成等等）

解析流程：
一堆判断标签开始结束、属性等等的正则
按照 面向过程 思考 ， 把html字符串边匹配、边截取

通过栈判断标签的父子关系

#### 7、然后把AST转化为render方法字符串

遍历AST，一点点拼接字符串